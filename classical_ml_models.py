# -*- coding: utf-8 -*-
"""classical_ml_models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f4ZuWpch2j-WfEY6MyBLpcoF_o5AvqSS
"""

from sklearn.pipeline import make_pipeline
import numpy as np
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import GridSearchCV, GroupKFold
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.cluster import KMeans
from xgboost import XGBClassifier
import pandas as pd
from sklearn.datasets import make_classification
import umap.umap_ as umap

# Use for validation
# Sample parameters for now

def svm_model(data, labels, val_data, svm_param):

  # For validation, train on full 3/4 data and then test on untouched 1/4 validation data?

  # PARAMETERS: kernal, C, gamma, degree

  # # Make predictions
  # y_pred = svm_model.predict(X_test)
  X_train = data
  y_train = labels
  X_test = val_data

  # Pipeline w/ UMAP + SVM

  # Create UMAP object
  reducer = umap.UMAP(n_components=5, n_neighbors=5, min_dist=0.1, metrics='hamming')

  # Turn data into z-scores
  scl = StandardScaler()
  X_train = scl.fit_transform(X_train)
  X_test = scl.fit_transform(X_test)

  # Data has been reduced into two features from four
  X_train = reducer.fit_transform(X_train)
  X_test = reducer.fit_transform(X_test)

  # Train the model
  svm_model = SVC(kernel='rbf', C=1, gamma='auto', degree=1, random_state=42)
  svm_model.fit(X_train, y_train)

  # Make predictions
  y_pred = svm_model.predict(X_test)

  return y_pred

  # Calculate the accuracy
  # accuracy = accuracy_score(y_test, y_pred)
  # print(f"SVM Accuracy: {accuracy}")

def random_forest_model(data, labels, val_data, rf_param):

  # PARAMETERS: n_estimators, min_samples_leaf, max_features
  X_train = data
  y_train = labels
  X_test = val_data

  # Pipeline w/ UMAP + RF

  # Create UMAP object
  reducer = umap.UMAP(n_components=5, n_neighbors=5, min_dist=0.1, metrics='hamming')

  # Turn data into z-scores
  scl = StandardScaler()
  X_train = scl.fit_transform(X_train)
  X_test = scl.fit_transform(X_test)

  # Data has been reduced into two features from four
  X_train = reducer.fit_transform(X_train)
  X_test = reducer.fit_transform(X_test)

  # Train the model
  rf_model = RandomForestClassifier(max_features=25, n_estimators=10, min_samples_leaf=5)
  rf_model.fit(X_train, y_train)

  # Make predictions
  y_pred = rf_model.predict(X_test)

  return y_pred


def xg_boost_model(data, labels, val_data, xg_param):

  # PARAMETERS: max_depth, n_estimators, learning_rate
  X_train = data
  y_train = labels
  X_test = val_data

  # Pipeline w/ UMAP + XG Boost

  # Create UMAP object
  reducer = umap.UMAP(n_components=5, n_neighbors=5, min_dist=0.1, metrics='hamming')

  # Turn data into z-scores
  scl = StandardScaler()
  X_train = scl.fit_transform(X_train)
  X_test = scl.fit_transform(X_test)

  # Data has been reduced into two features from four
  X_train = reducer.fit_transform(X_train)
  X_test = reducer.fit_transform(X_test)

  # Train the model
  xg_model = XGBClassifier(max_depth=2, n_estimators=50, learning_rate=0.1)
  xg_model.fit(X_train, y_train)

  # Make predictions
  y_pred = xg_model.predict(X_test)

  return y_pred


def kmeans_model(data, labels, val_data, kmeans_param):

  # PARAMETERS: n_clusters, init
  X_train = data
  y_train = labels
  X_test = val_data

  # Pipeline w/ UMAP + K Means

  # Create UMAP object
  reducer = umap.UMAP(n_components=5, n_neighbors=5, min_dist=0.1, metrics='hamming')

  # Turn data into z-scores
  scl = StandardScaler()
  X_train = scl.fit_transform(X_train)
  X_test = scl.fit_transform(X_test)

  # Data has been reduced into two features from four
  X_train = reducer.fit_transform(X_train)
  X_test = reducer.fit_transform(X_test)

  # Train the model
  kmeans_model = KMeans(n_clusters=2, init='kmeans++')
  kmeans_model.fit(X_train, y_train)

  # Make predictions
  y_pred = kmeans_model.predict(X_test)

  return y_pred

  print(f"K-Means Accuracy: ")